diff --git a/third/marked.min.js b/third/marked.min.js
index 3a83d90..b6b28ec 100644
--- a/third/marked.min.js
+++ b/third/marked.min.js
@@ -1,3 +1,8 @@
+/**
+ * marked v11.1.1 - a markdown parser
+ * Copyright (c) 2011-2024, Christopher Jeffrey. (MIT Licensed)
+ * https://github.com/markedjs/marked
+ */
 !(function (e, t) {
   'object' == typeof exports && 'undefined' != typeof module
     ? t(exports)
@@ -19,21 +24,36 @@
     l = new RegExp(i.source, 'g'),
     o = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' },
     a = (e) => o[e];
-  function c(e, t) {
+  function u(e, t) {
     if (t) {
       if (s.test(e)) return e.replace(r, a);
     } else if (i.test(e)) return e.replace(l, a);
     return e;
   }
-  const h = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/gi;
+  const c = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/gi;
+  function h(e) {
+    return e.replace(c, (e, t) =>
+      'colon' === (t = t.toLowerCase())
+        ? ':'
+        : '#' === t.charAt(0)
+        ? 'x' === t.charAt(1)
+          ? String.fromCharCode(parseInt(t.substring(2), 16))
+          : String.fromCharCode(+t.substring(1))
+        : ''
+    );
+  }
   const p = /(^|[^\[])\^/g;
-  function u(e, t) {
-    (e = 'string' == typeof e ? e : e.source), (t = t || '');
-    const n = {
-      replace: (t, s) => ((s = (s = 'object' == typeof s && 'source' in s ? s.source : s).replace(p, '$1')), (e = e.replace(t, s)), n),
-      getRegex: () => new RegExp(e, t)
+  function k(e, t) {
+    let n = 'string' == typeof e ? e : e.source;
+    t = t || '';
+    const s = {
+      replace: (e, t) => {
+        let r = 'string' == typeof t ? t : t.source;
+        return (r = r.replace(p, '$1')), (n = n.replace(e, r)), s;
+      },
+      getRegex: () => new RegExp(n, t)
     };
-    return n;
+    return s;
   }
   function g(e) {
     try {
@@ -43,8 +63,8 @@
     }
     return e;
   }
-  const k = { exec: () => null };
-  function f(e, t) {
+  const f = { exec: () => null };
+  function d(e, t) {
     const n = e
       .replace(/\|/g, (e, t, n) => {
         let s = !1,
@@ -60,7 +80,7 @@
     for (; s < n.length; s++) n[s] = n[s].trim().replace(/\\\|/g, '|');
     return n;
   }
-  function d(e, t, n) {
+  function x(e, t, n) {
     const s = e.length;
     if (0 === s) return '';
     let r = 0;
@@ -73,18 +93,18 @@
     }
     return e.slice(0, s - r);
   }
-  function x(e, t, n, s) {
+  function b(e, t, n, s) {
     const r = t.href,
-      i = t.title ? c(t.title) : null,
+      i = t.title ? u(t.title) : null,
       l = e[1].replace(/\\([\[\]])/g, '$1');
     if ('!' !== e[0].charAt(0)) {
       s.state.inLink = !0;
       const e = { type: 'link', raw: n, href: r, title: i, text: l, tokens: s.inlineTokens(l) };
       return (s.state.inLink = !1), e;
     }
-    return { type: 'image', raw: n, href: r, title: i, text: c(l) };
+    return { type: 'image', raw: n, href: r, title: i, text: u(l) };
   }
-  class b {
+  class w {
     options;
     rules;
     lexer;
@@ -99,7 +119,7 @@
       const t = this.rules.block.code.exec(e);
       if (t) {
         const e = t[0].replace(/^ {1,4}/gm, '');
-        return { type: 'code', raw: t[0], codeBlockStyle: 'indented', text: this.options.pedantic ? e : d(e, '\n') };
+        return { type: 'code', raw: t[0], codeBlockStyle: 'indented', text: this.options.pedantic ? e : x(e, '\n') };
       }
     }
     fences(e) {
@@ -120,7 +140,7 @@
               })
               .join('\n');
           })(e, t[3] || '');
-        return { type: 'code', raw: e, lang: t[2] ? t[2].trim().replace(this.rules.inline._escapes, '$1') : t[2], text: n };
+        return { type: 'code', raw: e, lang: t[2] ? t[2].trim().replace(this.rules.inline.anyPunctuation, '$1') : t[2], text: n };
       }
     }
     heading(e) {
@@ -128,7 +148,7 @@
       if (t) {
         let e = t[2].trim();
         if (/#$/.test(e)) {
-          const t = d(e, '#');
+          const t = x(e, '#');
           this.options.pedantic ? (e = t.trim()) : (t && !/ $/.test(t)) || (e = t.trim());
         }
         return { type: 'heading', raw: t[0], depth: t[1].length, text: e, tokens: this.lexer.inline(e) };
@@ -141,7 +161,7 @@
     blockquote(e) {
       const t = this.rules.block.blockquote.exec(e);
       if (t) {
-        const e = t[0].replace(/^ *>[ \t]?/gm, ''),
+        const e = x(t[0].replace(/^ *>[ \t]?/gm, ''), '\n'),
           n = this.lexer.state.top;
         this.lexer.state.top = !0;
         const s = this.lexer.blockTokens(e);
@@ -165,38 +185,38 @@
           if (this.rules.block.hr.test(e)) break;
           (l = t[0]), (e = e.substring(l.length));
           let s = t[2].split('\n', 1)[0].replace(/^\t+/, (e) => ' '.repeat(3 * e.length)),
-            c = e.split('\n', 1)[0],
-            h = 0;
-          this.options.pedantic ? ((h = 2), (o = s.trimStart())) : ((h = t[2].search(/[^ ]/)), (h = h > 4 ? 1 : h), (o = s.slice(h)), (h += t[1].length));
-          let p = !1;
-          if ((!s && /^ *$/.test(c) && ((l += c + '\n'), (e = e.substring(c.length + 1)), (n = !0)), !n)) {
-            const t = new RegExp(`^ {0,${Math.min(3, h - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ \t][^\\n]*)?(?:\\n|$))`),
-              n = new RegExp(`^ {0,${Math.min(3, h - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`),
-              r = new RegExp(`^ {0,${Math.min(3, h - 1)}}(?:\`\`\`|~~~)`),
-              i = new RegExp(`^ {0,${Math.min(3, h - 1)}}#`);
+            u = e.split('\n', 1)[0],
+            c = 0;
+          this.options.pedantic ? ((c = 2), (o = s.trimStart())) : ((c = t[2].search(/[^ ]/)), (c = c > 4 ? 1 : c), (o = s.slice(c)), (c += t[1].length));
+          let h = !1;
+          if ((!s && /^ *$/.test(u) && ((l += u + '\n'), (e = e.substring(u.length + 1)), (n = !0)), !n)) {
+            const t = new RegExp(`^ {0,${Math.min(3, c - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ \t][^\\n]*)?(?:\\n|$))`),
+              n = new RegExp(`^ {0,${Math.min(3, c - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`),
+              r = new RegExp(`^ {0,${Math.min(3, c - 1)}}(?:\`\`\`|~~~)`),
+              i = new RegExp(`^ {0,${Math.min(3, c - 1)}}#`);
             for (; e; ) {
               const a = e.split('\n', 1)[0];
-              if (((c = a), this.options.pedantic && (c = c.replace(/^ {1,4}(?=( {4})*[^ ])/g, '  ')), r.test(c))) break;
-              if (i.test(c)) break;
-              if (t.test(c)) break;
+              if (((u = a), this.options.pedantic && (u = u.replace(/^ {1,4}(?=( {4})*[^ ])/g, '  ')), r.test(u))) break;
+              if (i.test(u)) break;
+              if (t.test(u)) break;
               if (n.test(e)) break;
-              if (c.search(/[^ ]/) >= h || !c.trim()) o += '\n' + c.slice(h);
+              if (u.search(/[^ ]/) >= c || !u.trim()) o += '\n' + u.slice(c);
               else {
-                if (p) break;
+                if (h) break;
                 if (s.search(/[^ ]/) >= 4) break;
                 if (r.test(s)) break;
                 if (i.test(s)) break;
                 if (n.test(s)) break;
-                o += '\n' + c;
+                o += '\n' + u;
               }
-              p || c.trim() || (p = !0), (l += a + '\n'), (e = e.substring(a.length + 1)), (s = c.slice(h));
+              h || u.trim() || (h = !0), (l += a + '\n'), (e = e.substring(a.length + 1)), (s = u.slice(c));
             }
           }
           r.loose || (a ? (r.loose = !0) : /\n *\n *$/.test(l) && (a = !0));
-          let u,
-            g = null;
-          this.options.gfm && ((g = /^\[[ xX]\] /.exec(o)), g && ((u = '[ ] ' !== g[0]), (o = o.replace(/^\[[ xX]\] +/, '')))),
-            r.items.push({ type: 'list_item', raw: l, task: !!g, checked: u, loose: !1, text: o, tokens: [] }),
+          let p,
+            k = null;
+          this.options.gfm && ((k = /^\[[ xX]\] /.exec(o)), k && ((p = '[ ] ' !== k[0]), (o = o.replace(/^\[[ xX]\] +/, '')))),
+            r.items.push({ type: 'list_item', raw: l, task: !!k, checked: p, loose: !1, text: o, tokens: [] }),
             (r.raw += l);
         }
         (r.items[r.items.length - 1].raw = l.trimEnd()), (r.items[r.items.length - 1].text = o.trimEnd()), (r.raw = r.raw.trimEnd());
@@ -220,37 +240,25 @@
       const t = this.rules.block.def.exec(e);
       if (t) {
         const e = t[1].toLowerCase().replace(/\s+/g, ' '),
-          n = t[2] ? t[2].replace(/^<(.*)>$/, '$1').replace(this.rules.inline._escapes, '$1') : '',
-          s = t[3] ? t[3].substring(1, t[3].length - 1).replace(this.rules.inline._escapes, '$1') : t[3];
+          n = t[2] ? t[2].replace(/^<(.*)>$/, '$1').replace(this.rules.inline.anyPunctuation, '$1') : '',
+          s = t[3] ? t[3].substring(1, t[3].length - 1).replace(this.rules.inline.anyPunctuation, '$1') : t[3];
         return { type: 'def', tag: e, raw: t[0], href: n, title: s };
       }
     }
     table(e) {
       const t = this.rules.block.table.exec(e);
-      if (t) {
-        const e = {
-          type: 'table',
-          raw: t[0],
-          header: f(t[1]).map((e) => ({ text: e, tokens: [] })),
-          align: t[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
-          rows: t[3] && t[3].trim() ? t[3].replace(/\n[ \t]*$/, '').split('\n') : []
-        };
-        if (e.header.length === e.align.length) {
-          let t,
-            n,
-            s,
-            r,
-            i = e.align.length;
-          for (t = 0; t < i; t++) {
-            const n = e.align[t];
-            n &&
-              (/^ *-+: *$/.test(n) ? (e.align[t] = 'right') : /^ *:-+: *$/.test(n) ? (e.align[t] = 'center') : /^ *:-+ *$/.test(n) ? (e.align[t] = 'left') : (e.align[t] = null));
-          }
-          for (i = e.rows.length, t = 0; t < i; t++) e.rows[t] = f(e.rows[t], e.header.length).map((e) => ({ text: e, tokens: [] }));
-          for (i = e.header.length, n = 0; n < i; n++) e.header[n].tokens = this.lexer.inline(e.header[n].text);
-          for (i = e.rows.length, n = 0; n < i; n++) for (r = e.rows[n], s = 0; s < r.length; s++) r[s].tokens = this.lexer.inline(r[s].text);
-          return e;
-        }
+      if (!t) return;
+      if (!/[:|]/.test(t[2])) return;
+      const n = d(t[1]),
+        s = t[2].replace(/^\||\| *$/g, '').split('|'),
+        r = t[3] && t[3].trim() ? t[3].replace(/\n[ \t]*$/, '').split('\n') : [],
+        i = { type: 'table', raw: t[0], header: [], align: [], rows: [] };
+      if (n.length === s.length) {
+        for (const e of s)
+          /^ *-+: *$/.test(e) ? i.align.push('right') : /^ *:-+: *$/.test(e) ? i.align.push('center') : /^ *:-+ *$/.test(e) ? i.align.push('left') : i.align.push(null);
+        for (const e of n) i.header.push({ text: e, tokens: this.lexer.inline(e) });
+        for (const e of r) i.rows.push(d(e, i.header.length).map((e) => ({ text: e, tokens: this.lexer.inline(e) })));
+        return i;
       }
     }
     lheading(e) {
@@ -270,7 +278,7 @@
     }
     escape(e) {
       const t = this.rules.inline.escape.exec(e);
-      if (t) return { type: 'escape', raw: t[0], text: c(t[1]) };
+      if (t) return { type: 'escape', raw: t[0], text: u(t[1]) };
     }
     tag(e) {
       const t = this.rules.inline.tag.exec(e);
@@ -289,7 +297,7 @@
         const e = t[2].trim();
         if (!this.options.pedantic && /^</.test(e)) {
           if (!/>$/.test(e)) return;
-          const t = d(e.slice(0, -1), '\\');
+          const t = x(e.slice(0, -1), '\\');
           if ((e.length - t.length) % 2 == 0) return;
         } else {
           const e = (function (e, t) {
@@ -315,23 +323,23 @@
         return (
           (n = n.trim()),
           /^</.test(n) && (n = this.options.pedantic && !/>$/.test(e) ? n.slice(1) : n.slice(1, -1)),
-          x(t, { href: n ? n.replace(this.rules.inline._escapes, '$1') : n, title: s ? s.replace(this.rules.inline._escapes, '$1') : s }, t[0], this.lexer)
+          b(t, { href: n ? n.replace(this.rules.inline.anyPunctuation, '$1') : n, title: s ? s.replace(this.rules.inline.anyPunctuation, '$1') : s }, t[0], this.lexer)
         );
       }
     }
     reflink(e, t) {
       let n;
       if ((n = this.rules.inline.reflink.exec(e)) || (n = this.rules.inline.nolink.exec(e))) {
-        let e = (n[2] || n[1]).replace(/\s+/g, ' ');
-        if (((e = t[e.toLowerCase()]), !e)) {
+        const e = t[(n[2] || n[1]).replace(/\s+/g, ' ').toLowerCase()];
+        if (!e) {
           const e = n[0].charAt(0);
           return { type: 'text', raw: e, text: e };
         }
-        return x(n, e, n[0], this.lexer);
+        return b(n, e, n[0], this.lexer);
       }
     }
     emStrong(e, t, n = '') {
-      let s = this.rules.inline.emStrong.lDelim.exec(e);
+      let s = this.rules.inline.emStrongLDelim.exec(e);
       if (!s) return;
       if (s[3] && n.match(/[\p{L}\p{N}]/u)) return;
       if (!(s[1] || s[2] || '') || !n || this.rules.inline.punctuation.exec(n)) {
@@ -340,7 +348,7 @@
           i,
           l = n,
           o = 0;
-        const a = '*' === s[0][0] ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
+        const a = '*' === s[0][0] ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
         for (a.lastIndex = 0, t = t.slice(-1 * e.length + n); null != (s = a.exec(t)); ) {
           if (((r = s[1] || s[2] || s[3] || s[4] || s[5] || s[6]), !r)) continue;
           if (((i = [...r].length), s[3] || s[4])) {
@@ -353,13 +361,14 @@
           }
           if (((l -= i), l > 0)) continue;
           i = Math.min(i, i + l + o);
-          const t = [...e].slice(0, n + s.index + i + 1).join('');
+          const t = [...s[0]][0].length,
+            a = e.slice(0, n + s.index + t + i);
           if (Math.min(n, i) % 2) {
-            const e = t.slice(1, -1);
-            return { type: 'em', raw: t, text: e, tokens: this.lexer.inlineTokens(e) };
+            const e = a.slice(1, -1);
+            return { type: 'em', raw: a, text: e, tokens: this.lexer.inlineTokens(e) };
           }
-          const a = t.slice(2, -2);
-          return { type: 'strong', raw: t, text: a, tokens: this.lexer.inlineTokens(a) };
+          const u = a.slice(2, -2);
+          return { type: 'strong', raw: a, text: u, tokens: this.lexer.inlineTokens(u) };
         }
       }
     }
@@ -369,7 +378,7 @@
         let e = t[2].replace(/\n/g, ' ');
         const n = /[^ ]/.test(e),
           s = /^ /.test(e) && / $/.test(e);
-        return n && s && (e = e.substring(1, e.length - 1)), (e = c(e, !0)), { type: 'codespan', raw: t[0], text: e };
+        return n && s && (e = e.substring(1, e.length - 1)), (e = u(e, !0)), { type: 'codespan', raw: t[0], text: e };
       }
     }
     br(e) {
@@ -385,7 +394,7 @@
       if (t) {
         let e, n;
         return (
-          '@' === t[2] ? ((e = c(t[1])), (n = 'mailto:' + e)) : ((e = c(t[1])), (n = e)), { type: 'link', raw: t[0], text: e, href: n, tokens: [{ type: 'text', raw: e, text: e }] }
+          '@' === t[2] ? ((e = u(t[1])), (n = 'mailto:' + e)) : ((e = u(t[1])), (n = e)), { type: 'link', raw: t[0], text: e, href: n, tokens: [{ type: 'text', raw: e, text: e }] }
         );
       }
     }
@@ -393,13 +402,13 @@
       let t;
       if ((t = this.rules.inline.url.exec(e))) {
         let e, n;
-        if ('@' === t[2]) (e = c(t[0])), (n = 'mailto:' + e);
+        if ('@' === t[2]) (e = u(t[0])), (n = 'mailto:' + e);
         else {
           let s;
           do {
-            (s = t[0]), (t[0] = this.rules.inline._backpedal.exec(t[0])[0]);
+            (s = t[0]), (t[0] = this.rules.inline._backpedal.exec(t[0])?.[0] ?? '');
           } while (s !== t[0]);
-          (e = c(t[0])), (n = 'www.' === t[1] ? 'http://' + t[0] : t[0]);
+          (e = u(t[0])), (n = 'www.' === t[1] ? 'http://' + t[0] : t[0]);
         }
         return { type: 'link', raw: t[0], text: e, href: n, tokens: [{ type: 'text', raw: e, text: e }] };
       }
@@ -408,88 +417,92 @@
       const t = this.rules.inline.text.exec(e);
       if (t) {
         let e;
-        return (e = this.lexer.state.inRawBlock ? t[0] : c(t[0])), { type: 'text', raw: t[0], text: e };
+        return (e = this.lexer.state.inRawBlock ? t[0] : u(t[0])), { type: 'text', raw: t[0], text: e };
       }
     }
   }
-  const m = {
-    newline: /^(?: *(?:\n|$))+/,
-    code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
-    fences: /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
-    hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
-    heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
-    blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
-    list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
-    html: '^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))',
-    def: /^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
-    table: k,
-    lheading: /^((?:(?!^bull ).|\n(?!\n|bull ))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
-    _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
-    text: /^[^\n]+/,
-    _label: /(?!\s*\])(?:\\.|[^\[\]\\])+/,
-    _title: /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/
-  };
-  (m.def = u(m.def).replace('label', m._label).replace('title', m._title).getRegex()),
-    (m.bullet = /(?:[*+-]|\d{1,9}[.)])/),
-    (m.listItemStart = u(/^( *)(bull) */)
-      .replace('bull', m.bullet)
-      .getRegex()),
-    (m.list = u(m.list)
-      .replace(/bull/g, m.bullet)
-      .replace('hr', '\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))')
-      .replace('def', '\\n+(?=' + m.def.source + ')')
-      .getRegex()),
-    (m._tag =
-      'address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul'),
-    (m._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/),
-    (m.html = u(m.html, 'i')
-      .replace('comment', m._comment)
-      .replace('tag', m._tag)
+  const m = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
+    y = /(?:[*+-]|\d{1,9}[.)])/,
+    A = k(/^(?!bull )((?:.|\n(?!\s*?\n|bull ))+?)\n {0,3}(=+|-+) *(?:\n+|$)/)
+      .replace(/bull/g, y)
+      .getRegex(),
+    F = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
+    $ = /(?!\s*\])(?:\\.|[^\[\]\\])+/,
+    z = k(/^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/)
+      .replace('label', $)
+      .replace('title', /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/)
+      .getRegex(),
+    E = k(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/)
+      .replace(/bull/g, y)
+      .getRegex(),
+    T =
+      'address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul',
+    R = /<!--(?!-?>)[\s\S]*?(?:-->|$)/,
+    _ = k(
+      '^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))',
+      'i'
+    )
+      .replace('comment', R)
+      .replace('tag', T)
       .replace('attribute', / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/)
-      .getRegex()),
-    (m.lheading = u(m.lheading).replace(/bull/g, m.bullet).getRegex()),
-    (m.paragraph = u(m._paragraph)
-      .replace('hr', m.hr)
-      .replace('heading', ' {0,3}#{1,6} ')
+      .getRegex(),
+    D = k(F)
+      .replace('hr', m)
+      .replace('heading', ' {0,3}#{1,6}(?:\\s|$)')
       .replace('|lheading', '')
       .replace('|table', '')
       .replace('blockquote', ' {0,3}>')
       .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
       .replace('list', ' {0,3}(?:[*+-]|1[.)]) ')
       .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
-      .replace('tag', m._tag)
-      .getRegex()),
-    (m.blockquote = u(m.blockquote).replace('paragraph', m.paragraph).getRegex()),
-    (m.normal = { ...m }),
-    (m.gfm = {
-      ...m.normal,
-      table: '^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)'
-    }),
-    (m.gfm.table = u(m.gfm.table)
-      .replace('hr', m.hr)
-      .replace('heading', ' {0,3}#{1,6} ')
+      .replace('tag', T)
+      .getRegex(),
+    C = {
+      blockquote: k(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/)
+        .replace('paragraph', D)
+        .getRegex(),
+      code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
+      def: z,
+      fences: /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
+      heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
+      hr: m,
+      html: _,
+      lheading: A,
+      list: E,
+      newline: /^(?: *(?:\n|$))+/,
+      paragraph: D,
+      table: f,
+      text: /^[^\n]+/
+    },
+    B = k('^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)')
+      .replace('hr', m)
+      .replace('heading', ' {0,3}#{1,6}(?:\\s|$)')
       .replace('blockquote', ' {0,3}>')
       .replace('code', ' {4}[^\\n]')
       .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
       .replace('list', ' {0,3}(?:[*+-]|1[.)]) ')
       .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
-      .replace('tag', m._tag)
-      .getRegex()),
-    (m.gfm.paragraph = u(m._paragraph)
-      .replace('hr', m.hr)
-      .replace('heading', ' {0,3}#{1,6} ')
-      .replace('|lheading', '')
-      .replace('table', m.gfm.table)
-      .replace('blockquote', ' {0,3}>')
-      .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
-      .replace('list', ' {0,3}(?:[*+-]|1[.)]) ')
-      .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
-      .replace('tag', m._tag)
-      .getRegex()),
-    (m.pedantic = {
-      ...m.normal,
-      html: u('^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))')
-        .replace('comment', m._comment)
+      .replace('tag', T)
+      .getRegex(),
+    S = {
+      ...C,
+      table: B,
+      paragraph: k(F)
+        .replace('hr', m)
+        .replace('heading', ' {0,3}#{1,6}(?:\\s|$)')
+        .replace('|lheading', '')
+        .replace('table', B)
+        .replace('blockquote', ' {0,3}>')
+        .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
+        .replace('list', ' {0,3}(?:[*+-]|1[.)]) ')
+        .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
+        .replace('tag', T)
+        .getRegex()
+    },
+    I = {
+      ...C,
+      html: k('^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))')
+        .replace('comment', R)
         .replace(
           /tag/g,
           '(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b'
@@ -497,96 +510,118 @@
         .getRegex(),
       def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
       heading: /^(#{1,6})(.*)(?:\n+|$)/,
-      fences: k,
+      fences: f,
       lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
-      paragraph: u(m.normal._paragraph)
-        .replace('hr', m.hr)
+      paragraph: k(F)
+        .replace('hr', m)
         .replace('heading', ' *#{1,6} *[^\n]')
-        .replace('lheading', m.lheading)
+        .replace('lheading', A)
+        .replace('|table', '')
         .replace('blockquote', ' {0,3}>')
         .replace('|fences', '')
         .replace('|list', '')
         .replace('|html', '')
+        .replace('|tag', '')
         .getRegex()
-    });
-  const w = {
-    escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
-    autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
-    url: k,
-    tag: '^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>',
-    link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
-    reflink: /^!?\[(label)\]\[(ref)\]/,
-    nolink: /^!?\[(ref)\](?:\[\])?/,
-    reflinkSearch: 'reflink|nolink(?!\\()',
-    emStrong: {
-      lDelim: /^(?:\*+(?:((?!\*)[punct])|[^\s*]))|^_+(?:((?!_)[punct])|([^\s_]))/,
-      rDelimAst:
-        /^[^_*]*?__[^_*]*?\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\*)[punct](\*+)(?=[\s]|$)|[^punct\s](\*+)(?!\*)(?=[punct\s]|$)|(?!\*)[punct\s](\*+)(?=[^punct\s])|[\s](\*+)(?!\*)(?=[punct])|(?!\*)[punct](\*+)(?!\*)(?=[punct])|[^punct\s](\*+)(?=[^punct\s])/,
-      rDelimUnd:
-        /^[^_*]*?\*\*[^_*]*?_[^_*]*?(?=\*\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\s]|$)|[^punct\s](_+)(?!_)(?=[punct\s]|$)|(?!_)[punct\s](_+)(?=[^punct\s])|[\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])/
     },
-    code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
-    br: /^( {2,}|\\)\n(?!\s*$)/,
-    del: k,
-    text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
-    punctuation: /^((?![*_])[\spunctuation])/,
-    _punctuation: '\\p{P}$+<=>`^|~'
-  };
-  (w.punctuation = u(w.punctuation, 'u')
-    .replace(/punctuation/g, w._punctuation)
-    .getRegex()),
-    (w.blockSkip = /\[[^[\]]*?\]\([^\(\)]*?\)|`[^`]*?`|<[^<>]*?>/g),
-    (w.anyPunctuation = /\\[punct]/g),
-    (w._escapes = /\\([punct])/g),
-    (w._comment = u(m._comment).replace('(?:--\x3e|$)', '--\x3e').getRegex()),
-    (w.emStrong.lDelim = u(w.emStrong.lDelim, 'u').replace(/punct/g, w._punctuation).getRegex()),
-    (w.emStrong.rDelimAst = u(w.emStrong.rDelimAst, 'gu').replace(/punct/g, w._punctuation).getRegex()),
-    (w.emStrong.rDelimUnd = u(w.emStrong.rDelimUnd, 'gu').replace(/punct/g, w._punctuation).getRegex()),
-    (w.anyPunctuation = u(w.anyPunctuation, 'gu').replace(/punct/g, w._punctuation).getRegex()),
-    (w._escapes = u(w._escapes, 'gu').replace(/punct/g, w._punctuation).getRegex()),
-    (w._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/),
-    (w._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/),
-    (w.autolink = u(w.autolink).replace('scheme', w._scheme).replace('email', w._email).getRegex()),
-    (w._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/),
-    (w.tag = u(w.tag).replace('comment', w._comment).replace('attribute', w._attribute).getRegex()),
-    (w._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/),
-    (w._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/),
-    (w._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/),
-    (w.link = u(w.link).replace('label', w._label).replace('href', w._href).replace('title', w._title).getRegex()),
-    (w.reflink = u(w.reflink).replace('label', w._label).replace('ref', m._label).getRegex()),
-    (w.nolink = u(w.nolink).replace('ref', m._label).getRegex()),
-    (w.reflinkSearch = u(w.reflinkSearch, 'g').replace('reflink', w.reflink).replace('nolink', w.nolink).getRegex()),
-    (w.normal = { ...w }),
-    (w.pedantic = {
-      ...w.normal,
-      strong: { start: /^__|\*\*/, middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/, endAst: /\*\*(?!\*)/g, endUnd: /__(?!_)/g },
-      em: { start: /^_|\*/, middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/, endAst: /\*(?!\*)/g, endUnd: /_(?!_)/g },
-      link: u(/^!?\[(label)\]\((.*?)\)/)
-        .replace('label', w._label)
+    Z = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
+    q = /^( {2,}|\\)\n(?!\s*$)/,
+    L =
+      '!"#$%&\'()+\\-.,/:;<=>?@\\[\\]`^{|}~\\\\\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E42\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65',
+    P = k(/^((?![*_])[\spunctuation])/, 'u')
+      .replace(/punctuation/g, L)
+      .getRegex(),
+    Q = k(/^(?:\*+(?:((?!\*)[punct])|[^\s*]))|^_+(?:((?!_)[punct])|([^\s_]))/, 'u')
+      .replace(/punct/g, L)
+      .getRegex(),
+    v = k(
+      '^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)[punct](\\*+)(?=[\\s]|$)|[^punct\\s](\\*+)(?!\\*)(?=[punct\\s]|$)|(?!\\*)[punct\\s](\\*+)(?=[^punct\\s])|[\\s](\\*+)(?!\\*)(?=[punct])|(?!\\*)[punct](\\*+)(?!\\*)(?=[punct])|[^punct\\s](\\*+)(?=[^punct\\s])',
+      'gu'
+    )
+      .replace(/punct/g, L)
+      .getRegex(),
+    M = k(
+      '^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\\s]|$)|[^punct\\s](_+)(?!_)(?=[punct\\s]|$)|(?!_)[punct\\s](_+)(?=[^punct\\s])|[\\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])',
+      'gu'
+    )
+      .replace(/punct/g, L)
+      .getRegex(),
+    O = k(/\\([punct])/, 'gu')
+      .replace(/punct/g, L)
+      .getRegex(),
+    j = k(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/)
+      .replace('scheme', /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/)
+      .replace('email', /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/)
+      .getRegex(),
+    H = k(R).replace('(?:--\x3e|$)', '--\x3e').getRegex(),
+    U = k('^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>')
+      .replace('comment', H)
+      .replace('attribute', /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/)
+      .getRegex(),
+    X = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/,
+    N = k(/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/)
+      .replace('label', X)
+      .replace('href', /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/)
+      .replace('title', /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/)
+      .getRegex(),
+    G = k(/^!?\[(label)\]\[(ref)\]/)
+      .replace('label', X)
+      .replace('ref', $)
+      .getRegex(),
+    J = k(/^!?\[(ref)\](?:\[\])?/)
+      .replace('ref', $)
+      .getRegex(),
+    K = {
+      _backpedal: f,
+      anyPunctuation: O,
+      autolink: j,
+      blockSkip: /\[[^[\]]*?\]\([^\(\)]*?\)|`[^`]*?`|<[^<>]*?>/g,
+      br: q,
+      code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
+      del: f,
+      emStrongLDelim: Q,
+      emStrongRDelimAst: v,
+      emStrongRDelimUnd: M,
+      escape: Z,
+      link: N,
+      nolink: J,
+      punctuation: P,
+      reflink: G,
+      reflinkSearch: k('reflink|nolink(?!\\()', 'g').replace('reflink', G).replace('nolink', J).getRegex(),
+      tag: U,
+      text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
+      url: f
+    },
+    V = {
+      ...K,
+      link: k(/^!?\[(label)\]\((.*?)\)/)
+        .replace('label', X)
         .getRegex(),
-      reflink: u(/^!?\[(label)\]\s*\[([^\]]*)\]/)
-        .replace('label', w._label)
+      reflink: k(/^!?\[(label)\]\s*\[([^\]]*)\]/)
+        .replace('label', X)
         .getRegex()
-    }),
-    (w.gfm = {
-      ...w.normal,
-      escape: u(w.escape).replace('])', '~|])').getRegex(),
-      _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
-      url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
+    },
+    W = {
+      ...K,
+      escape: k(Z).replace('])', '~|])').getRegex(),
+      url: k(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, 'i')
+        .replace('email', /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/)
+        .getRegex(),
       _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
       del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
       text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
-    }),
-    (w.gfm.url = u(w.gfm.url, 'i').replace('email', w.gfm._extended_email).getRegex()),
-    (w.breaks = {
-      ...w.gfm,
-      br: u(w.br).replace('{2,}', '*').getRegex(),
-      text: u(w.gfm.text)
+    },
+    Y = {
+      ...W,
+      br: k(q).replace('{2,}', '*').getRegex(),
+      text: k(W.text)
         .replace('\\b_', '\\b_| {2,}\\n')
         .replace(/\{2,\}/g, '*')
         .getRegex()
-    });
-  class _ {
+    },
+    ee = { normal: C, gfm: S, pedantic: I },
+    te = { normal: K, gfm: W, breaks: Y, pedantic: V };
+  class ne {
     tokens;
     options;
     state;
@@ -596,31 +631,34 @@
       (this.tokens = []),
         (this.tokens.links = Object.create(null)),
         (this.options = t || e.defaults),
-        (this.options.tokenizer = this.options.tokenizer || new b()),
+        (this.options.tokenizer = this.options.tokenizer || new w()),
         (this.tokenizer = this.options.tokenizer),
         (this.tokenizer.options = this.options),
         (this.tokenizer.lexer = this),
         (this.inlineQueue = []),
         (this.state = { inLink: !1, inRawBlock: !1, top: !0 });
-      const n = { block: m.normal, inline: w.normal };
+      const n = { block: ee.normal, inline: te.normal };
       this.options.pedantic
-        ? ((n.block = m.pedantic), (n.inline = w.pedantic))
-        : this.options.gfm && ((n.block = m.gfm), this.options.breaks ? (n.inline = w.breaks) : (n.inline = w.gfm)),
+        ? ((n.block = ee.pedantic), (n.inline = te.pedantic))
+        : this.options.gfm && ((n.block = ee.gfm), this.options.breaks ? (n.inline = te.breaks) : (n.inline = te.gfm)),
         (this.tokenizer.rules = n);
     }
     static get rules() {
-      return { block: m, inline: w };
+      return { block: ee, inline: te };
     }
     static lex(e, t) {
-      return new _(t).lex(e);
+      return new ne(t).lex(e);
     }
     static lexInline(e, t) {
-      return new _(t).inlineTokens(e);
+      return new ne(t).inlineTokens(e);
     }
     lex(e) {
-      let t;
-      for (e = e.replace(/\r\n|\r/g, '\n'), this.blockTokens(e, this.tokens); (t = this.inlineQueue.shift()); ) this.inlineTokens(t.src, t.tokens);
-      return this.tokens;
+      (e = e.replace(/\r\n|\r/g, '\n')), this.blockTokens(e, this.tokens);
+      for (let e = 0; e < this.inlineQueue.length; e++) {
+        const t = this.inlineQueue[e];
+        this.inlineTokens(t.src, t.tokens);
+      }
+      return (this.inlineQueue = []), this.tokens;
     }
     blockTokens(e, t = []) {
       let n, s, r, i;
@@ -757,7 +795,7 @@
       return t;
     }
   }
-  class y {
+  class se {
     options;
     constructor(t) {
       this.options = t || e.defaults;
@@ -766,7 +804,7 @@
       const s = (t || '').match(/^\S*/)?.[0];
       return (
         (e = e.replace(/\n$/, '') + '\n'),
-        s ? '<pre><code class="language-' + c(s) + '">' + (n ? e : c(e, !0)) + '</code></pre>\n' : '<pre><code>' + (n ? e : c(e, !0)) + '</code></pre>\n'
+        s ? '<pre><code class="language-' + u(s) + '">' + (n ? e : u(e, !0)) + '</code></pre>\n' : '<pre><code>' + (n ? e : u(e, !0)) + '</code></pre>\n'
       );
     }
     blockquote(e) {
@@ -835,7 +873,7 @@
       return e;
     }
   }
-  class $ {
+  class re {
     strong(e) {
       return e;
     }
@@ -864,22 +902,22 @@
       return '';
     }
   }
-  class z {
+  class ie {
     options;
     renderer;
     textRenderer;
     constructor(t) {
       (this.options = t || e.defaults),
-        (this.options.renderer = this.options.renderer || new y()),
+        (this.options.renderer = this.options.renderer || new se()),
         (this.renderer = this.options.renderer),
         (this.renderer.options = this.options),
-        (this.textRenderer = new $());
+        (this.textRenderer = new re());
     }
     static parse(e, t) {
-      return new z(t).parse(e);
+      return new ie(t).parse(e);
     }
     static parseInline(e, t) {
-      return new z(t).parseInline(e);
+      return new ie(t).parseInline(e);
     }
     parse(e, t = !0) {
       let n = '';
@@ -901,19 +939,7 @@
             continue;
           case 'heading': {
             const e = r;
-            n += this.renderer.heading(
-              this.parseInline(e.tokens),
-              e.depth,
-              this.parseInline(e.tokens, this.textRenderer).replace(h, (e, t) =>
-                'colon' === (t = t.toLowerCase())
-                  ? ':'
-                  : '#' === t.charAt(0)
-                  ? 'x' === t.charAt(1)
-                    ? String.fromCharCode(parseInt(t.substring(2), 16))
-                    : String.fromCharCode(+t.substring(1))
-                  : ''
-              )
-            );
+            n += this.renderer.heading(this.parseInline(e.tokens), e.depth, h(this.parseInline(e.tokens, this.textRenderer)));
             continue;
           }
           case 'code': {
@@ -1068,32 +1094,33 @@
       return n;
     }
   }
-  class T {
+  class le {
     options;
     constructor(t) {
       this.options = t || e.defaults;
     }
-    static passThroughHooks = new Set(['preprocess', 'postprocess']);
+    static passThroughHooks = new Set(['preprocess', 'postprocess', 'processAllTokens']);
     preprocess(e) {
       return e;
     }
     postprocess(e) {
       return e;
     }
+    processAllTokens(e) {
+      return e;
+    }
   }
-  class R {
+  class oe {
     defaults = { async: !1, breaks: !1, extensions: null, gfm: !0, hooks: null, pedantic: !1, renderer: null, silent: !1, tokenizer: null, walkTokens: null };
     options = this.setOptions;
-    parse = this.#e(_.lex, z.parse);
-    parseInline = this.#e(_.lexInline, z.parseInline);
-    Parser = z;
-    parser = z.parse;
-    Renderer = y;
-    TextRenderer = $;
-    Lexer = _;
-    lexer = _.lex;
-    Tokenizer = b;
-    Hooks = T;
+    parse = this.#e(ne.lex, ie.parse);
+    parseInline = this.#e(ne.lexInline, ie.parseInline);
+    Parser = ie;
+    Renderer = se;
+    TextRenderer = re;
+    Lexer = ne;
+    Tokenizer = w;
+    Hooks = le;
     constructor(...e) {
       this.use(...e);
     }
@@ -1158,45 +1185,51 @@
               (n.extensions = t)),
             e.renderer)
           ) {
-            const t = this.defaults.renderer || new y(this.defaults);
+            const t = this.defaults.renderer || new se(this.defaults);
             for (const n in e.renderer) {
-              const s = e.renderer[n],
-                r = n,
-                i = t[r];
-              t[r] = (...e) => {
-                let n = s.apply(t, e);
+              if (!(n in t)) throw new Error(`renderer '${n}' does not exist`);
+              if ('options' === n) continue;
+              const s = n,
+                r = e.renderer[s],
+                i = t[s];
+              t[s] = (...e) => {
+                let n = r.apply(t, e);
                 return !1 === n && (n = i.apply(t, e)), n || '';
               };
             }
             n.renderer = t;
           }
           if (e.tokenizer) {
-            const t = this.defaults.tokenizer || new b(this.defaults);
+            const t = this.defaults.tokenizer || new w(this.defaults);
             for (const n in e.tokenizer) {
-              const s = e.tokenizer[n],
-                r = n,
-                i = t[r];
-              t[r] = (...e) => {
-                let n = s.apply(t, e);
+              if (!(n in t)) throw new Error(`tokenizer '${n}' does not exist`);
+              if (['options', 'rules', 'lexer'].includes(n)) continue;
+              const s = n,
+                r = e.tokenizer[s],
+                i = t[s];
+              t[s] = (...e) => {
+                let n = r.apply(t, e);
                 return !1 === n && (n = i.apply(t, e)), n;
               };
             }
             n.tokenizer = t;
           }
           if (e.hooks) {
-            const t = this.defaults.hooks || new T();
+            const t = this.defaults.hooks || new le();
             for (const n in e.hooks) {
-              const s = e.hooks[n],
-                r = n,
-                i = t[r];
-              T.passThroughHooks.has(n)
-                ? (t[r] = (e) => {
-                    if (this.defaults.async) return Promise.resolve(s.call(t, e)).then((e) => i.call(t, e));
-                    const n = s.call(t, e);
+              if (!(n in t)) throw new Error(`hook '${n}' does not exist`);
+              if ('options' === n) continue;
+              const s = n,
+                r = e.hooks[s],
+                i = t[s];
+              le.passThroughHooks.has(n)
+                ? (t[s] = (e) => {
+                    if (this.defaults.async) return Promise.resolve(r.call(t, e)).then((e) => i.call(t, e));
+                    const n = r.call(t, e);
                     return i.call(t, n);
                   })
-                : (t[r] = (...e) => {
-                    let n = s.apply(t, e);
+                : (t[s] = (...e) => {
+                    let n = r.apply(t, e);
                     return !1 === n && (n = i.apply(t, e)), n;
                   });
             }
@@ -1218,6 +1251,12 @@
     setOptions(e) {
       return (this.defaults = { ...this.defaults, ...e }), this;
     }
+    lexer(e, t) {
+      return ne.lex(e, t ?? this.defaults);
+    }
+    parser(e, t) {
+      return ie.parse(e, t ?? this.defaults);
+    }
     #e(e, t) {
       return (n, s) => {
         const r = { ...s },
@@ -1231,14 +1270,15 @@
         if ((i.hooks && (i.hooks.options = i), i.async))
           return Promise.resolve(i.hooks ? i.hooks.preprocess(n) : n)
             .then((t) => e(t, i))
+            .then((e) => (i.hooks ? i.hooks.processAllTokens(e) : e))
             .then((e) => (i.walkTokens ? Promise.all(this.walkTokens(e, i.walkTokens)).then(() => e) : e))
             .then((e) => t(e, i))
             .then((e) => (i.hooks ? i.hooks.postprocess(e) : e))
             .catch(l);
         try {
           i.hooks && (n = i.hooks.preprocess(n));
-          const s = e(n, i);
-          i.walkTokens && this.walkTokens(s, i.walkTokens);
+          let s = e(n, i);
+          i.hooks && (s = i.hooks.processAllTokens(s)), i.walkTokens && this.walkTokens(s, i.walkTokens);
           let r = t(s, i);
           return i.hooks && (r = i.hooks.postprocess(r)), r;
         } catch (e) {
@@ -1249,7 +1289,7 @@
     #t(e, t) {
       return (n) => {
         if (((n.message += '\nPlease report this to https://github.com/markedjs/marked.'), e)) {
-          const e = '<p>An error occurred:</p><pre>' + c(n.message + '', !0) + '</pre>';
+          const e = '<p>An error occurred:</p><pre>' + u(n.message + '', !0) + '</pre>';
           return t ? Promise.resolve(e) : e;
         }
         if (t) return Promise.reject(n);
@@ -1257,55 +1297,55 @@
       };
     }
   }
-  const S = new R();
-  function A(e, t) {
-    return S.parse(e, t);
+  const ae = new oe();
+  function ue(e, t) {
+    return ae.parse(e, t);
   }
-  (A.options = A.setOptions =
+  (ue.options = ue.setOptions =
     function (e) {
-      return S.setOptions(e), (A.defaults = S.defaults), n(A.defaults), A;
+      return ae.setOptions(e), (ue.defaults = ae.defaults), n(ue.defaults), ue;
     }),
-    (A.getDefaults = t),
-    (A.defaults = e.defaults),
-    (A.use = function (...e) {
-      return S.use(...e), (A.defaults = S.defaults), n(A.defaults), A;
+    (ue.getDefaults = t),
+    (ue.defaults = e.defaults),
+    (ue.use = function (...e) {
+      return ae.use(...e), (ue.defaults = ae.defaults), n(ue.defaults), ue;
     }),
-    (A.walkTokens = function (e, t) {
-      return S.walkTokens(e, t);
+    (ue.walkTokens = function (e, t) {
+      return ae.walkTokens(e, t);
     }),
-    (A.parseInline = S.parseInline),
-    (A.Parser = z),
-    (A.parser = z.parse),
-    (A.Renderer = y),
-    (A.TextRenderer = $),
-    (A.Lexer = _),
-    (A.lexer = _.lex),
-    (A.Tokenizer = b),
-    (A.Hooks = T),
-    (A.parse = A);
-  const I = A.options,
-    E = A.setOptions,
-    Z = A.use,
-    q = A.walkTokens,
-    L = A.parseInline,
-    D = A,
-    P = z.parse,
-    v = _.lex;
-  (e.Hooks = T),
-    (e.Lexer = _),
-    (e.Marked = R),
-    (e.Parser = z),
-    (e.Renderer = y),
-    (e.TextRenderer = $),
-    (e.Tokenizer = b),
+    (ue.parseInline = ae.parseInline),
+    (ue.Parser = ie),
+    (ue.parser = ie.parse),
+    (ue.Renderer = se),
+    (ue.TextRenderer = re),
+    (ue.Lexer = ne),
+    (ue.lexer = ne.lex),
+    (ue.Tokenizer = w),
+    (ue.Hooks = le),
+    (ue.parse = ue);
+  const ce = ue.options,
+    he = ue.setOptions,
+    pe = ue.use,
+    ke = ue.walkTokens,
+    ge = ue.parseInline,
+    fe = ue,
+    de = ie.parse,
+    xe = ne.lex;
+  (e.Hooks = le),
+    (e.Lexer = ne),
+    (e.Marked = oe),
+    (e.Parser = ie),
+    (e.Renderer = se),
+    (e.TextRenderer = re),
+    (e.Tokenizer = w),
     (e.getDefaults = t),
-    (e.lexer = v),
-    (e.marked = A),
-    (e.options = I),
-    (e.parse = D),
-    (e.parseInline = L),
-    (e.parser = P),
-    (e.setOptions = E),
-    (e.use = Z),
-    (e.walkTokens = q);
+    (e.lexer = xe),
+    (e.marked = ue),
+    (e.options = ce),
+    (e.parse = fe),
+    (e.parseInline = ge),
+    (e.parser = de),
+    (e.setOptions = he),
+    (e.use = pe),
+    (e.walkTokens = ke);
 });
